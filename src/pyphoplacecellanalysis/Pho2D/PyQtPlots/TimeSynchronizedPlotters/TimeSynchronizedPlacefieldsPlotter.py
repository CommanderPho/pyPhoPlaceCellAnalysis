import numpy as np
import pandas as pd
from qtpy import QtCore, QtWidgets

from neuropy.analyses.time_dependent_placefields import PfND_TimeDependent

import pyphoplacecellanalysis.External.pyqtgraph as pg
from pyphoplacecellanalysis.External.pyqtgraph.Qt import QtCore, QtGui
from pyphocorehelpers.DataStructure.general_parameter_containers import VisualizationParameters
from pyphocorehelpers.DataStructure.data_structure_builders import Width_Height_Tuple
from pyphocorehelpers.gui.PhoUIContainer import PhoUIContainer
from pyphocorehelpers.indexing_helpers import compute_paginated_grid_config
from pyphocorehelpers.geometry_helpers import compute_data_aspect_ratio, compute_data_extent
from pyphocorehelpers.print_helpers import generate_html_string

from pyphoplacecellanalysis.Pho2D.PyQtPlots.TimeSynchronizedPlotters.TimeSynchronizedPlotterBase import TimeSynchronizedPlotterBase
from pyphoplacecellanalysis.Pho2D.PyQtPlots.Extensions.pyqtgraph_helpers import pyqtplot_build_image_bounds_extent
from pyphoplacecellanalysis.Pho2D.PyQtPlots.TimeSynchronizedPlotters.Mixins.AnimalTrajectoryPlottingMixin import AnimalTrajectoryPlottingMixin


class TimeSynchronizedPlacefieldsPlotter(AnimalTrajectoryPlottingMixin, TimeSynchronizedPlotterBase):
    """ Renders the 2D placefields generated by a PfND_TimeDependent instance
    
    Usage:
        from pyphoplacecellanalysis.Pho2D.PyQtPlots.TimeSynchronizedPlotters.TimeSynchronizedPlacefieldsPlotter import TimeSynchronizedPlacefieldsPlotter
        from neuropy.analyses.time_dependent_placefields import PfND_TimeDependent

        included_epochs = None
        computation_config = active_session_computation_configs[0]
        # PfND version:
        t_list = []
        ratemaps_list = []
        active_time_dependent_placefields2D = PfND_TimeDependent(deepcopy(sess.spikes_df.copy()), deepcopy(sess.position), epochs=included_epochs,
                                          speed_thresh=computation_config.speed_thresh, frate_thresh=computation_config.frate_thresh,
                                          grid_bin=computation_config.grid_bin, smooth=computation_config.smooth)
        curr_sync_placefield_plotter = TimeSynchronizedPlacefieldsPlotter(active_time_dependent_placefields2D)
        curr_sync_placefield_plotter.show()

    """
    # Application/Window Configuration Options:
    applicationName = 'TimeSynchronizedPlacefieldsPlotterApp'
    windowName = 'TimeSynchronizedPlacefieldsPlotterWindow'
    
    
    enable_debug_print = False
    
    def __init__(self, active_time_dependent_placefields2D, drop_below_threshold: float=0.0000001, max_num_columns = 5, application_name=None, window_name=None, parent=None):
        """_summary_
        """
        super().__init__(application_name=application_name, window_name=(window_name or TimeSynchronizedPlacefieldsPlotter.windowName), parent=parent) # Call the inherited classes __init__ method
        
        self.active_time_dependent_placefields = active_time_dependent_placefields2D
        assert self.active_time_dependent_placefields.ndim > 1, f"TimeSynchronizedPlacefieldsPlotter only works for 2D currently!"
        self.setup()
        self.params.drop_below_threshold = drop_below_threshold
        self.params.max_num_columns = max_num_columns
        
        self.buildUI()
        self._update_plots()
        
    def setup(self):
        # self.setup_spike_rendering_mixin() # NeuronIdentityAccessingMixin
        self.app = pg.mkQApp(self.applicationName)
        self.params = VisualizationParameters(self.applicationName)
        # self.params.shared_axis_order = 'row-major'
        self.params.shared_axis_order = 'col-major'
        # self.params.shared_axis_order = None
        
        ## Build the colormap to be used:
        # self.params.cmap = pg.ColorMap(pos=np.linspace(0.0, 1.0, 6), color=colors)
        self.params.cmap = pg.colormap.get('jet','matplotlib') # prepare a linear color map
        self.params.image_margins = 0.0
        
        self.params.image_bounds_extent, self.params.x_range, self.params.y_range = pyqtplot_build_image_bounds_extent(self.active_time_dependent_placefields.xbin, self.active_time_dependent_placefields.ybin, margin=self.params.image_margins, debug_print=self.enable_debug_print)
        self.params.image_aspect_ratio, image_width_height_tuple = compute_data_aspect_ratio(self.params.x_range, self.params.y_range)
        # print(f'image_aspect_ratio: {self.params.image_aspect_ratio}, image_width_height_tuple: {image_width_height_tuple}')
        
        self.params.nMapsToShow = self.active_time_dependent_placefields.ratemap.n_neurons
        self.AnimalTrajectoryPlottingMixin_on_setup()
        self.params.trajectory_path_current_position_marker_size = 4.0
        # self.params.trajectory_path_marker_max_fill_opacity = 255
        self.params.trajectory_path_marker_max_fill_opacity = 150
        self.params.trajectory_path_current_position_marker_brush = pg.mkBrush(0, 255, 0, self.params.trajectory_path_marker_max_fill_opacity)
        self.params.recent_position_trajectory_symbol_pen = pg.mkPen({'color': [10, 120, 10, 200], 'width': 1}) # Dark Green
                
    def _buildGraphics(self):
        self.ui.img_item_array = []
        self.ui.other_components_array = []
        self.ui.plot_array = []
        
        # root_render_widget
        self.ui.root_graphics_layout_widget = pg.GraphicsLayoutWidget()
        
        curr_ratemap = self.active_time_dependent_placefields.ratemap
        images = curr_ratemap.tuning_curves.copy() # (43, 63, 63)
        occupancy = curr_ratemap.occupancy
        
        # Compute Images:
        included_unit_indicies = np.arange(np.shape(images)[0]) # include all unless otherwise specified
        nMapsToShow = len(included_unit_indicies)

        # Paging Management: Constrain the subplots values to just those that you need
        subplot_no_pagination_configuration, self.params.included_combined_indicies_pages, self.params.page_grid_sizes = compute_paginated_grid_config(nMapsToShow, max_num_columns=self.params.max_num_columns, max_subplots_per_page=None, data_indicies=included_unit_indicies, last_figure_subplots_same_layout=True)
        page_idx = 0 # page_idx is zero here because we only have one page:
        
        self.compute_desired_page_aspect_ratio()
        
        for (a_linear_index, curr_row, curr_col, curr_included_unit_index) in self.params.included_combined_indicies_pages[page_idx]:
            # Need to convert to page specific:
            curr_page_relative_linear_index = np.mod(a_linear_index, int(self.params.page_grid_sizes[page_idx].num_rows * self.params.page_grid_sizes[page_idx].num_columns))
            curr_page_relative_row = np.mod(curr_row, self.params.page_grid_sizes[page_idx].num_rows)
            curr_page_relative_col = np.mod(curr_col, self.params.page_grid_sizes[page_idx].num_columns)
            if self.enable_debug_print:
                print(f'a_linear_index: {a_linear_index}, curr_page_relative_linear_index: {curr_page_relative_linear_index}, curr_row: {curr_row}, curr_col: {curr_col}, curr_page_relative_row: {curr_page_relative_row}, curr_page_relative_col: {curr_page_relative_col}, curr_included_unit_index: {curr_included_unit_index}')
                
                
            is_first_column = (curr_page_relative_col == 0)
            is_first_row = (curr_page_relative_row == 0)
            is_last_column = (curr_page_relative_col == (self.params.page_grid_sizes[page_idx].num_columns-1))
            is_last_row = (curr_page_relative_row == (self.params.page_grid_sizes[page_idx].num_rows-1))
            
            neuron_IDX = curr_included_unit_index
            cell_ID = self.active_time_dependent_placefields.ratemap.neuron_ids[neuron_IDX]
            curr_cell_identifier_string = f'Cell[{cell_ID}]'
            curr_plot_identifier_string = f'TimeSynchronizedPlacefieldsPlotter.{curr_cell_identifier_string}'

            # Build the image item:
            # Update the image:
            image = np.squeeze(images[a_linear_index,:,:])
            # Pre-filter the data:
            with np.errstate(divide='ignore', invalid='ignore'):
                image = np.array(image) / np.nanmax(image) # note scaling by maximum here!
                if self.params.drop_below_threshold is not None:
                    image[np.where(occupancy < self.params.drop_below_threshold)] = np.nan # null out the occupancy
            
            img_item = pg.ImageItem(image=image, levels=(0,1), border='w')
            
            # curr_plot = self.ui.root_graphics_layout_widget.addPlot(row=curr_row, col=curr_col, title=curr_cell_identifier_string) #, font_size=8, font= font , name=curr_plot_identifier_string
            curr_plot = self.ui.root_graphics_layout_widget.addPlot(row=curr_row, col=curr_col, title=generate_html_string(input_str=curr_cell_identifier_string, font_size=2, color='grey')) # use a formatted string so it's smaller and grey
            curr_plot.setObjectName(curr_plot_identifier_string)
            curr_plot.addItem(img_item, defaultPadding=0.0)  # add ImageItem to PlotItem
            

            #TODO 2023-08-31 15:39: - [ ] Tried to make the title font smaller but doesn't work 
            # font = QtGui.QFont()
            # font.setPixelSize(8)

            # old_font = curr_plot.titleLabel.item.font()
            # old_font.setFamily("Serif")
            # old_font.setPixelSize(8)
            # curr_plot.titleLabel.item.setFont(old_font)


            # curr_plot.showAxes(True)
            
            # if not is_last_row and not is_first_column:
            curr_plot.showAxes(False)
            if is_last_row:
                curr_plot.showAxes('x', True)
                curr_plot.showAxis('bottom', show=True)
            else:
                curr_plot.showAxes('x', False)
                curr_plot.showAxis('bottom', show=False)
                
            if is_first_column:
                curr_plot.showAxes('y', True)
                curr_plot.showAxis('left', show=True)
            else:
                curr_plot.showAxes('y', False)
                curr_plot.showAxis('left', show=False)
            
            curr_plot.hideButtons() # Hides the auto-scale button
            
            curr_trajectory_curve = pg.PlotDataItem(pen=None, shadowPen=None, symbol='crosshair', pxMode=False, symbolSize=self.params.trajectory_path_current_position_marker_size, symbolPen=self.params.recent_position_trajectory_symbol_pen, symbolBrush=self.params.trajectory_path_current_position_marker_brush, antialias=True, name=f'animal position - {curr_cell_identifier_string}') #downsample=20, downsampleMethod='peak', autoDownsample=True, skipFiniteCheck=True, clipToView=True
            curr_plot.addItem(curr_trajectory_curve)
            
            # Update the image:
            if self.params.shared_axis_order is None:
                img_item.setImage(image, rect=self.params.image_bounds_extent, autoLevels=False) # rect: [x, y, w, h]
            else:
                img_item.setImage(image, rect=self.params.image_bounds_extent, autoLevels=False, axisOrder=self.params.shared_axis_order) # rect: [x, y, w, h] # , axisOrder='row-major'
                        
            img_item.setLookupTable(self.params.cmap.getLookupTable(nPts=256), update=False)

            curr_plot.setRange(xRange=self.params.x_range, yRange=self.params.y_range, padding=0.0, update=False, disableAutoRange=True)
            # Sets only the panning limits:
            curr_plot.setLimits(xMin=self.params.x_range[0], xMax=self.params.x_range[-1], yMin=self.params.y_range[0], yMax=self.params.y_range[-1])
            # curr_plot.setLimits(xMin=self.params.x_range[0], xMax=self.params.x_range[-1], yMin=self.params.y_range[0], yMax=self.params.y_range[-1])
            curr_plot.setMouseEnabled(x=False, y=False)
            curr_plot.setMenuEnabled(enableMenu=False)

            # Link Axes to previous item:
            if a_linear_index > 0:
                prev_plot_item = self.ui.plot_array[a_linear_index-1]
                curr_plot.setXLink(prev_plot_item)
                curr_plot.setYLink(prev_plot_item)

            # Lock the aspect ratio AFTER setting the x/y range:
            # curr_plot.setAspectLocked(lock=True, ratio=self.params.image_aspect_ratio) # # caused some sort of infinite loop in `linkedViewChanged`! 
            # curr_plot.setAspectLocked(True) # caused some sort of infinite loop in `linkedViewChanged`! 

            # Interactive Color Bar:
            # bar = pg.ColorBarItem(values= (0, 1), colorMap=self.params.cmap, width=5, interactive=False) # prepare interactive color bar
            # # Have ColorBarItem control colors of img and appear in 'plot':
            # bar.setImageItem(img_item, insert_in=curr_plot)
            bar = None

            self.ui.img_item_array.append(img_item)
            self.ui.plot_array.append(curr_plot)
            self.ui.other_components_array.append({'color_bar':bar, 'trajectory_curve': curr_trajectory_curve})
        

        # add the root_graphics_layout_widget to the main layout:
        self.ui.layout.addWidget(self.ui.root_graphics_layout_widget, 0, 0) # add the GLViewWidget to the layout at 0, 0
    
    
    def update(self, t, defer_render=False):
        # Compute the updated placefields/occupancy for the time t:
        with np.errstate(divide='ignore', invalid='ignore'):
            self.active_time_dependent_placefields.update(t)

        if not defer_render:
            self._update_plots()


    def _update_plots(self):
        if self.enable_debug_print:
            print(f'TimeSynchronizedPlacefieldsPlotter._update_plots()')
            
        # Update the existing one:
        
        # Update the plots:
        curr_t = self.active_time_dependent_placefields.last_t
        curr_ratemap = self.active_time_dependent_placefields.ratemap
        images = curr_ratemap.tuning_curves.copy() # (43, 63, 63)
        occupancy = curr_ratemap.occupancy
        # image = curr_ratemap.occupancy
        # image = self.active_time_dependent_placefields.curr_normalized_occupancy
        # image_title = 'curr_normalized_occupancy'
        image_title = 'tuning_curves'
        
        # Update the placefields plot if needed:
        for i, an_img_item in enumerate(self.ui.img_item_array):
            image = np.squeeze(images[i,:,:])
            # Pre-filter the data:
            with np.errstate(divide='ignore', invalid='ignore'):
                image = np.array(image) / np.nanmax(image) # note scaling by maximum here!
                if self.params.drop_below_threshold is not None:
                    image[np.where(occupancy < self.params.drop_below_threshold)] = np.nan # null out the occupancy
            # an_img_item.setImage(np.squeeze(images[i,:,:]))
            
            if self.params.shared_axis_order is None:
                an_img_item.setImage(image, autoLevels=False)
            else:
                an_img_item.setImage(image, autoLevels=False, axisOrder=self.params.shared_axis_order)
            
            ## Update the current position dot on the figure:
            curr_trajectory_curve = self.ui.other_components_array[i].get('trajectory_curve', None)
            if curr_trajectory_curve is not None:
                curr_position_row = self.curr_position
                curr_trajectory_curve.setData(x=curr_position_row.x.to_numpy(), y=curr_position_row.y.to_numpy()) 
            
        self.setWindowTitle(f'{image_title} t = {curr_t}')
    

    def compute_desired_page_aspect_ratio(self, debug_print=False):
        """ requires:
        self.params:
            .page_grid_sizes
            .image_aspect_ratio
            
        Sets:
        self.params:
            .page_width_height_tuple
            .page_aspect_ratio
        """
        ## Computes the appropriate size of the widget given the aspect-ratio of the image data and the number of rows/columns in the page layout:
        max_num_rows = max([a_rol_col_tuple.num_rows for a_rol_col_tuple in self.params.page_grid_sizes])
        max_num_cols = max([a_rol_col_tuple.num_columns for a_rol_col_tuple in self.params.page_grid_sizes])
        if debug_print:
            print(f'max_num_rows: {max_num_rows}, max_num_cols: {max_num_cols}')                   

        single_image_aspect_ratio = self.params.image_aspect_ratio # each single_image_width = 0.9776615738374339 * single_image_height 
        # aspect_ratio = width / height
        single_image_height = 1.0
        single_image_width = single_image_aspect_ratio * single_image_height
        # single_image_tuple = Width_Height_Tuple(single_image_width, single_image_height)
        page_height = single_image_height * float(max_num_rows)
        page_width = single_image_width * float(max_num_cols)
        page_width_height_tuple = Width_Height_Tuple(page_width, page_height) # Width_Height_Tuple(width=4.8883078691871695, height=11.0)
        page_aspect_ratio = page_width / page_height
        if debug_print:
            print(f'page_aspect_ratio: {page_aspect_ratio}') # 0.4443916244715609
        
        self.params.page_width_height_tuple = page_width_height_tuple
        self.params.page_aspect_ratio = page_aspect_ratio

    def desired_widget_size(self, desired_page_height = 600.0, desired_page_width = None, debug_print=False):
        """ Requires that self.compute_desired_page_aspect_ratio has already been called on the target 
        """
        ## Apply the computed page_aspect_ratio to an arbitrary desired height to get the appropriate width of the widget
        assert (desired_page_width is None) or (desired_page_height is None), "Either desired_page_height or desired_page_width must be None so the other can be computed"
        
        if desired_page_width is None:
            desired_page_width = self.params.page_aspect_ratio * desired_page_height
        elif desired_page_height is None:
            desired_page_height = desired_page_width / self.params.page_aspect_ratio
        else:
            raise NotImplementedError
        if debug_print:
            print(f'desired_page_height: {desired_page_height}, desired_page_width: {desired_page_width}')
        return Width_Height_Tuple(desired_page_width, desired_page_height)
            
            
# included_epochs = None
# computation_config = active_session_computation_configs[0]
# active_time_dependent_placefields2D = PfND_TimeDependent(deepcopy(sess.spikes_df.copy()), deepcopy(sess.position), epochs=included_epochs,
#                                   speed_thresh=computation_config.speed_thresh, frate_thresh=computation_config.frate_thresh,
#                                   grid_bin=computation_config.grid_bin, smooth=computation_config.smooth)
# curr_occupancy_plotter = TimeSynchronizedPlacefieldsPlotter(active_time_dependent_placefields2D)
# curr_occupancy_plotter.show()